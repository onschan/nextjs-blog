---
title: 테스트 제목3
date: "2022년 1월 1일"
description:
thumbnail: ""
tags: ["test"]
---

## 잉여 속성

### 잉여 속성 체크 = 엄격한 객체 리터럴 체크

잉여 속성 - 객체 리터럴의 속성 중 변수의 객체 타입에 선언된 속성에 포함되지 않는 속성

→ 변수에 객체 리터럴을 할당하는 경우, 할당할 객체 리터럴의 속성(프로퍼티) 중 잉여 속성이 있으면, 컴파일러 및 타입 체커가 에러를 발생시킨다.

→ 구조적 할당 가능한 검사와 잉여 속성 체크는 별도의 과정이다.

```typescript
// 잉여 속성 체크

interface SomeInterface {
  x: string;
  y: string;
}

const someVariable: SomeInterface = { x: "x", y: "y", z: "z" };
// 여기서 문제 발생, 잉여 속성 체크

/*
잉여 타입 체크 에러메시지
Type '{ x: string; y: string; z: string; }' is not assignable to type 'SomeInterface'.
Object literal may only specify known properties, and 'z' does not exist in type 'SomeInterface'.(2322)
*/
```

```ts
// 구조적 타이핑

interface SomeInterface {
  x: string;
  y: string;
}

const anotherVariable = { x: "x", y: "y", z: "z" };
// SomeInterface의 서브타입

// {x:string, y:string} <- { x:string; y: string; z: string } Ok
const someVariable: SomeInterface = anotherVariable; // 정상 실행
```

```c
<article
  ref={articleRef}
  css={css`
    * {
      scroll-margin-top: 50px;
    }

    pre {
      position: relative;

      &::after {
        ${typography.caption}
        content: attr(data-language);
        position: absolute;  // sticky 대신 absolute 사용
        top: 0;
        right: 0;
        display: inline-block;
        text-align: right;
        color: ${theme.text.tertiary};
        font-family: monospace;
        font-size: 12px;
        text-transform: uppercase;
        transform: translate(-14px, 14px);  // 위치 조정
        background: inherit;  // 코드 배경색과 동일하게
        border-radius: 0 12px 0 4px;  // 오른쪽 상단 모서리만 둥글게
        padding: 4px 8px;  // 여백 추가
      }

      code {
        display: inline-block;
      }
    }
  `}
>
```

```c++
<article
  ref={articleRef}
  css={css`
    * {
      scroll-margin-top: 50px;
    }

    pre {
      position: relative;

      &::after {
        ${typography.caption}
        content: attr(data-language);
        position: absolute;  // sticky 대신 absolute 사용
        top: 0;
        right: 0;
        display: inline-block;
        text-align: right;
        color: ${theme.text.tertiary};
        font-family: monospace;
        font-size: 12px;
        text-transform: uppercase;
        transform: translate(-14px, 14px);  // 위치 조정
        background: inherit;  // 코드 배경색과 동일하게
        border-radius: 0 12px 0 4px;  // 오른쪽 상단 모서리만 둥글게
        padding: 4px 8px;  // 여백 추가
      }

      code {
        display: inline-block;
      }
    }
  `}
>
```

```js
<article
  ref={articleRef}
  css={css`
    * {
      scroll-margin-top: 50px;
    }

    pre {
      position: relative;

      &::after {
        ${typography.caption}
        content: attr(data-language);
        position: absolute;  // sticky 대신 absolute 사용
        top: 0;
        right: 0;
        display: inline-block;
        text-align: right;
        color: ${theme.text.tertiary};
        font-family: monospace;
        font-size: 12px;
        text-transform: uppercase;
        transform: translate(-14px, 14px);  // 위치 조정
        background: inherit;  // 코드 배경색과 동일하게
        border-radius: 0 12px 0 4px;  // 오른쪽 상단 모서리만 둥글게
        padding: 4px 8px;  // 여백 추가
      }

      code {
        display: inline-block;
      }
    }
  `}
>
```

```c
<article
  ref={articleRef}
  css={css`
    * {
      scroll-margin-top: 50px;
    }

    pre {
      position: relative;

      &::after {
        ${typography.caption}
        content: attr(data-language);
        position: absolute;  // sticky 대신 absolute 사용
        top: 0;
        right: 0;
        display: inline-block;
        text-align: right;
        color: ${theme.text.tertiary};
        font-family: monospace;
        font-size: 12px;
        text-transform: uppercase;
        transform: translate(-14px, 14px);  // 위치 조정
        background: inherit;  // 코드 배경색과 동일하게
        border-radius: 0 12px 0 4px;  // 오른쪽 상단 모서리만 둥글게
        padding: 4px 8px;  // 여백 추가
      }

      code {
        display: inline-block;
      }
    }
  `}
>
```

```js
<article
  ref={articleRef}
  css={css`
    * {
      scroll-margin-top: 50px;
    }

    pre {
      position: relative;

      &::after {
        ${typography.caption}
        content: attr(data-language);
        position: absolute;  // sticky 대신 absolute 사용
        top: 0;
        right: 0;
        display: inline-block;
        text-align: right;
        color: ${theme.text.tertiary};
        font-family: monospace;
        font-size: 12px;
        text-transform: uppercase;
        transform: translate(-14px, 14px);  // 위치 조정
        background: inherit;  // 코드 배경색과 동일하게
        border-radius: 0 12px 0 4px;  // 오른쪽 상단 모서리만 둥글게
        padding: 4px 8px;  // 여백 추가
      }

      code {
        display: inline-block;
      }
    }
  `}
>
```

```command
"codepush:android": "appcenter codepush release-react -a <username>/<appname> -d Staging",
"codepush:ios": "appcenter codepush release-react -a <username>/<appname> -d Staging"
```

구조적 타이핑의 관점에서는 문제가 없다고 보일 수도 있지만,

객체 리터럴을 할당하는 과정에서 발생하는 잉여 속성 체크의 과정이다.

(따라서, 구조적 타이핑을 무시하는 예외적 경우이다.)

`{ x: 'x', y: 'y', z: 'z' }`라는 객체 리터럴을 직접 할당하는 상황과, 객체 리터럴을 미리 변수에 할당하고 해당 변수를 할당하는 상황과 동작은 같지만, 타입스크립트는 다르게 해석하고 에러를 전자의 상황만 에러를 발생시킨다.
